"""
ASP-specific validators for Answer Set Programming syntax and structure.

This module provides validation for ASP programs using Clingo, including:
- Syntax validation
- Type checking
- Stratification verification
- Satisfiability checking
- LLM-generated rule validation
- Undefined predicate detection
- Grounding validation
- Unsafe variable detection (issue #167)
- Embedded period detection (issue #168)
"""

from typing import Tuple, List, Optional, Dict, Any, Set
import re
import clingo
from loguru import logger

from loft.validation.validation_schemas import ValidationResult
from loft.neural.rule_schemas import (
    check_undefined_predicates,
    validate_rule_grounds,
)


def _extract_variables(text: str) -> Set[str]:
    """
    Extract ASP variables from a text fragment.

    ASP variables are uppercase identifiers (e.g., X, Contract, MyVar).
    This is a helper function to avoid duplicate regex patterns.

    Args:
        text: Text fragment to extract variables from

    Returns:
        Set of variable names found in the text
    """
    return set(re.findall(r"\b([A-Z][a-zA-Z0-9_]*)\b", text))


def check_unsafe_variables(rule_text: str) -> Tuple[List[str], List[str]]:
    """
    Check for unsafe variables in ASP rules (issue #167).

    In Clingo, every variable in the rule head MUST appear in at least one
    positive body literal. Variables that only appear in the head or in
    negative literals are "unsafe" and will cause grounding errors.

    Note: This is a heuristic check designed for simple ASP rules commonly
    generated by LLMs. It may not correctly handle all ASP constructs:
    - Nested parentheses in predicates (e.g., pred(f(X)))
    - Choice rules (e.g., {head(X)} :- body(X).)
    - Disjunctive heads (e.g., a(X) | b(X) :- c(X).)
    - Aggregates (e.g., #count{X : pred(X)} > 0)
    - Arithmetic expressions (e.g., Y = X + 1)

    For production use with complex ASP, consider using Clingo's AST parser
    via clingo.ast.parse_string() for accurate variable extraction.

    Args:
        rule_text: The ASP rule to check

    Returns:
        Tuple of (errors, warnings):
        - errors: List of unsafe variable error messages
        - warnings: List of potential safety warning messages

    Example:
        >>> errors, warnings = check_unsafe_variables(
        ...     "cause_of_harm(X, Fall) :- dangerous_condition(X)."
        ... )
        >>> assert "Fall" in errors[0]  # Fall is unsafe
    """
    errors = []
    warnings = []

    # Skip if not a rule (no body)
    if ":-" not in rule_text:
        return errors, warnings

    # Split into head and body
    try:
        head_part, body_part = rule_text.split(":-", 1)
    except ValueError:
        return errors, warnings

    # Extract variables from head using helper
    head_variables = _extract_variables(head_part)

    # Extract variables from positive body literals
    # First, remove negative literals for positive literal analysis
    positive_body = body_part

    # Remove negative literals (not pred(...))
    positive_body = re.sub(r"\bnot\s+[a-z_][a-zA-Z0-9_]*\s*\([^)]*\)", "", positive_body)

    # Extract variables from positive body literals using helper
    positive_body_variables = _extract_variables(positive_body)

    # Check for unsafe variables (in head but not in positive body)
    unsafe_variables = head_variables - positive_body_variables

    if unsafe_variables:
        for var in sorted(unsafe_variables):
            errors.append(
                f"Unsafe variable '{var}': appears in rule head but not in any "
                f"positive body literal. Clingo requires all head variables to be "
                f"grounded in the body."
            )

    # Check for variables only in negative literals (potential issue)
    negative_only_vars = _extract_negative_only_variables(body_part, positive_body_variables)
    if negative_only_vars:
        for var in sorted(negative_only_vars):
            warnings.append(
                f"Variable '{var}' appears only in negative literals. "
                f"Ensure it is bound elsewhere in the rule body."
            )

    return errors, warnings


def _extract_negative_only_variables(body_part: str, positive_vars: Set[str]) -> Set[str]:
    """
    Extract variables that appear only in negative literals.

    Args:
        body_part: The body of the rule
        positive_vars: Set of variables already found in positive literals

    Returns:
        Set of variable names that only appear in negative literals
    """
    # Find all variables in negative literals
    negative_pattern = r"\bnot\s+[a-z_][a-zA-Z0-9_]*\s*\(([^)]*)\)"
    negative_matches = re.findall(negative_pattern, body_part)

    negative_vars = set()
    for match in negative_matches:
        negative_vars.update(_extract_variables(match))

    # Return variables only in negative literals
    return negative_vars - positive_vars


def check_embedded_periods(rule_text: str) -> Tuple[List[str], List[str]]:
    """
    Check for embedded periods in ASP rules (issue #168).

    LLMs sometimes generate rules with OOP-style dot notation instead of proper
    ASP syntax. For example: `physical_harm(Spectator.FoulBall)` instead of
    `injured_by(Spectator, FoulBall)`.

    In valid ASP, periods (.) only appear:
    1. At the end of a rule/fact as a terminator
    2. In floating-point numbers (e.g., 3.14)

    This function detects:
    - OOP-style dot notation: Var.OtherVar, Var.predicate
    - Embedded periods within predicate arguments
    - Method-style calls: object.method()

    Args:
        rule_text: The ASP rule to check

    Returns:
        Tuple of (errors, warnings):
        - errors: List of embedded period error messages
        - warnings: List of potential issues that might be false positives

    Example:
        >>> errors, warnings = check_embedded_periods(
        ...     "physical_harm(Spectator.FoulBall) :- at_game(Spectator)."
        ... )
        >>> assert len(errors) > 0  # Detects OOP-style dot notation
        >>> assert "Spectator.FoulBall" in errors[0]
    """
    errors = []
    warnings = []

    # Remove the trailing period (valid terminator)
    rule_stripped = rule_text.rstrip()
    if rule_stripped.endswith("."):
        rule_stripped = rule_stripped[:-1]

    # Pattern 1: OOP-style dot notation - Variable.Variable or Variable.predicate
    # Matches: Spectator.FoulBall, Object.method, Var.something
    oop_pattern = r"\b([A-Z][a-zA-Z0-9_]*)\.([a-zA-Z][a-zA-Z0-9_]*)\b"
    oop_matches = re.findall(oop_pattern, rule_stripped)

    for match in oop_matches:
        full_match = f"{match[0]}.{match[1]}"
        errors.append(
            f"Embedded period detected (OOP-style dot notation): '{full_match}'. "
            f"ASP uses commas to separate arguments, not dots. "
            f"Consider: '{match[0]}, {match[1]}' or a different predicate structure."
        )

    # Pattern 2: lowercase.lowercase (method-style or namespace)
    # Matches: object.method, module.predicate
    method_pattern = r"\b([a-z][a-zA-Z0-9_]*)\.([a-z][a-zA-Z0-9_]*)\b"
    method_matches = re.findall(method_pattern, rule_stripped)

    for match in method_matches:
        full_match = f"{match[0]}.{match[1]}"
        # Skip if it looks like a floating-point number context
        errors.append(
            f"Embedded period detected (method-style notation): '{full_match}'. "
            f"ASP does not support method calls or namespaced predicates. "
            f"Use separate predicates or underscores: '{match[0]}_{match[1]}'."
        )

    # Pattern 3: Any period followed by non-whitespace (except at very end)
    # This catches remaining cases like foo.bar(X)
    # But exclude floating-point numbers like 3.14
    general_period_pattern = r"\.(?!\s*$)"
    period_positions = [m.start() for m in re.finditer(general_period_pattern, rule_stripped)]

    for pos in period_positions:
        # Check if it's part of a floating-point number
        before = rule_stripped[max(0, pos - 5) : pos]
        after = rule_stripped[pos + 1 : min(len(rule_stripped), pos + 6)]

        # Skip if surrounded by digits (floating-point number)
        if re.search(r"\d$", before) and re.search(r"^\d", after):
            continue

        # Skip if already captured by OOP or method patterns
        context = rule_stripped[max(0, pos - 20) : min(len(rule_stripped), pos + 20)]
        already_reported = any(
            f"{m[0]}.{m[1]}" in context for m in oop_matches + method_matches
        )
        if not already_reported:
            warnings.append(
                f"Unexpected period found at position {pos} in rule. "
                f"Context: '...{context}...'. "
                f"Periods should only terminate rules, not appear mid-rule."
            )

    return errors, warnings


class ASPSyntaxValidator:
    """Validates ASP program syntax and structure."""

    def __init__(
        self,
        strict_undefined_predicates: bool = False,
        validate_grounding: bool = False,
    ):
        """
        Initialize the ASP syntax validator.

        Args:
            strict_undefined_predicates: If True, undefined predicates cause rejection
            validate_grounding: If True, test that rules ground with sample facts
        """
        self.strict_undefined_predicates = strict_undefined_predicates
        self.validate_grounding = validate_grounding

    def validate_generated_rule(
        self,
        rule_text: str,
        existing_predicates: Optional[List[str]] = None,
        sample_facts: Optional[str] = None,
    ) -> ValidationResult:
        """
        Validate an LLM-generated ASP rule with comprehensive checks.

        This method performs specialized validation for rules generated by LLMs,
        including syntax, naming conventions, structural checks, undefined
        predicate detection, and optional grounding validation.

        Args:
            rule_text: The ASP rule to validate
            existing_predicates: Optional list of existing predicates
                                 (e.g., ["contract/1", "party/2"] or ["contract", "party"])
            sample_facts: Optional sample facts to test grounding against

        Returns:
            ValidationResult with detailed error messages and warnings

        Example:
            >>> validator = ASPSyntaxValidator(strict_undefined_predicates=True)
            >>> result = validator.validate_generated_rule(
            ...     "enforceable(C) :- contract(C), not void(C).",
            ...     existing_predicates=["contract/1", "void/1"]
            ... )
            >>> assert result.is_valid
        """
        errors = []
        warnings = []
        details = {}

        # 1. Basic syntax validation with Clingo
        syntax_valid, syntax_error = self.validate_program(rule_text)
        if not syntax_valid:
            errors.append(f"Syntax error: {syntax_error}")
            return ValidationResult(
                is_valid=False,
                error_messages=errors,
                warnings=warnings,
                details={"syntax_error": syntax_error},
                stage_name="syntactic",
            )

        # 1b. Check for unsafe variables (issue #167)
        unsafe_errors, unsafe_warnings = check_unsafe_variables(rule_text)
        if unsafe_errors:
            errors.extend(unsafe_errors)
            details["unsafe_variables"] = unsafe_errors
        if unsafe_warnings:
            warnings.extend(unsafe_warnings)

        # 1c. Check for embedded periods (issue #168)
        period_errors, period_warnings = check_embedded_periods(rule_text)
        if period_errors:
            errors.extend(period_errors)
            details["embedded_periods"] = period_errors
        if period_warnings:
            warnings.extend(period_warnings)

        # 2. Variable naming convention check (uppercase)
        variable_issues = self._check_variable_naming(rule_text)
        if variable_issues:
            warnings.extend(variable_issues)
            details["variable_naming_issues"] = variable_issues

        # 3. Predicate naming convention check (lowercase, underscore-separated)
        predicate_issues = self._check_predicate_naming(rule_text)
        if predicate_issues:
            warnings.extend(predicate_issues)
            details["predicate_naming_issues"] = predicate_issues

        # 4. Check for proper negation syntax
        negation_issues = self._check_negation_syntax(rule_text)
        if negation_issues:
            errors.extend(negation_issues)
            details["negation_issues"] = negation_issues

        # 5. Check for constraint formatting
        constraint_issues = self._check_constraint_formatting(rule_text)
        if constraint_issues:
            warnings.extend(constraint_issues)
            details["constraint_issues"] = constraint_issues

        # 6. Validate against existing predicates if provided
        if existing_predicates:
            predicate_compatibility = self._check_predicate_compatibility(
                rule_text, existing_predicates
            )
            if predicate_compatibility:
                details["new_predicates"] = predicate_compatibility.get("new_predicates", [])
                details["used_predicates"] = predicate_compatibility.get("used_predicates", [])

            # 6b. Check for undefined predicates (new in issue #101)
            known_pred_names = self._extract_predicate_names(existing_predicates)
            undef_errors, undef_warnings = check_undefined_predicates(
                rule_text, known_pred_names, strict=self.strict_undefined_predicates
            )
            errors.extend(undef_errors)
            warnings.extend(undef_warnings)
            if undef_errors or undef_warnings:
                details["undefined_predicates"] = undef_errors + undef_warnings

        # 7. Check for common LLM generation issues
        llm_issues = self._check_common_llm_issues(rule_text)
        if llm_issues:
            warnings.extend(llm_issues)
            details["llm_generation_issues"] = llm_issues

        # 8. Grounding validation (new in issue #101)
        if self.validate_grounding and sample_facts:
            grounds, grounding_error = validate_rule_grounds(rule_text, sample_facts)
            if not grounds:
                warnings.append(f"Grounding issue: {grounding_error}")
                details["grounding_issue"] = grounding_error

        is_valid = len(errors) == 0

        return ValidationResult(
            is_valid=is_valid,
            error_messages=errors,
            warnings=warnings,
            details=details,
            stage_name="syntactic",
        )

    def _extract_predicate_names(self, predicate_specs: List[str]) -> Set[str]:
        """
        Extract predicate names from predicate specs.

        Args:
            predicate_specs: List like ["contract/1", "party/2"] or ["contract", "party"]

        Returns:
            Set of predicate names
        """
        names = set()
        for spec in predicate_specs:
            if "/" in spec:
                name = spec.split("/")[0]
            else:
                name = spec
            names.add(name.strip())
        return names

    def _check_variable_naming(self, rule_text: str) -> List[str]:
        """Check that variables follow uppercase naming convention."""
        issues = []

        # Find potential variables (words in rule that start with lowercase in head/body positions)
        # This is a heuristic check - proper parsing would use Clingo AST
        var_pattern = r"\b([a-z][a-zA-Z0-9_]*)\b"
        matches = re.finditer(var_pattern, rule_text)

        lowercase_in_args = []
        for match in matches:
            var = match.group(1)
            # Check if it appears in argument position (after '(' or ',')
            pos = match.start()
            if pos > 0 and rule_text[pos - 1] in "(,":
                # Exclude predicate names (those followed by '(')
                if match.end() < len(rule_text) and rule_text[match.end()] != "(":
                    lowercase_in_args.append(var)

        if lowercase_in_args:
            issues.append(
                f"Potential variable naming issue: variables should be uppercase. "
                f"Found lowercase in argument positions: {', '.join(set(lowercase_in_args[:5]))}"
            )

        return issues

    def _check_predicate_naming(self, rule_text: str) -> List[str]:
        """Check that predicates follow naming conventions."""
        issues = []

        # Find predicate names (words followed by '(')
        pred_pattern = r"([A-Z][a-zA-Z0-9_]*)\s*\("
        matches = re.finditer(pred_pattern, rule_text)

        uppercase_predicates = [m.group(1) for m in matches]

        if uppercase_predicates:
            issues.append(
                f"Predicate naming convention: predicates should start with lowercase. "
                f"Found uppercase predicates: {', '.join(set(uppercase_predicates))}"
            )

        return issues

    def _check_negation_syntax(self, rule_text: str) -> List[str]:
        """Check for proper negation syntax."""
        errors = []

        # Check for improper negation patterns
        # ASP uses 'not' for default negation, '-' for classical negation

        # Look for common mistakes like '!' instead of 'not'
        if "!" in rule_text and "not" not in rule_text:
            errors.append("Invalid negation syntax: use 'not' instead of '!'")

        # Check for negation with missing space
        if re.search(r"not[a-zA-Z]", rule_text):
            errors.append("Negation syntax: 'not' should be followed by a space")

        return errors

    def _check_constraint_formatting(self, rule_text: str) -> List[str]:
        """Check constraint formatting."""
        issues = []

        # Check if this is a constraint (starts with ':-')
        if rule_text.strip().startswith(":-"):
            # Good practice: constraints should have clear variable usage
            if not any(var in rule_text for var in ["(X)", "(Y)", "(C)", "(P)"]):
                issues.append("Constraint may need explicit variables for clarity")

        return issues

    def _check_predicate_compatibility(
        self, rule_text: str, existing_predicates: List[str]
    ) -> Dict[str, List[str]]:
        """
        Check which predicates are used vs new.

        Args:
            rule_text: The rule text
            existing_predicates: List of predicates in format "name/arity"

        Returns:
            Dict with "new_predicates" and "used_predicates" lists
        """
        # Parse existing predicates into a dict
        existing_dict = {}
        for pred_spec in existing_predicates:
            if "/" in pred_spec:
                name, arity = pred_spec.split("/")
                existing_dict[name] = int(arity)

        # Extract predicates from rule (simplified heuristic)
        pred_pattern = r"([a-z][a-z0-9_]*)\s*\("
        found_predicates = set(re.findall(pred_pattern, rule_text))

        new_predicates = []
        used_predicates = []

        for pred in found_predicates:
            if pred in existing_dict:
                used_predicates.append(pred)
            else:
                new_predicates.append(pred)

        return {
            "new_predicates": new_predicates,
            "used_predicates": used_predicates,
        }

    def _check_common_llm_issues(self, rule_text: str) -> List[str]:
        """Check for common issues in LLM-generated rules."""
        issues = []

        # Check for missing period at end
        if not rule_text.strip().endswith("."):
            issues.append("Rule should end with a period (.)")

        # Check for multiple rules in one string (should be split)
        if rule_text.count(".") > 1:
            issues.append("Multiple rules detected - consider validating separately")

        # Check for incomplete rules (empty body or head)
        if ":-" in rule_text:
            parts = rule_text.split(":-")
            if len(parts) == 2:
                head, body = parts
                if not head.strip():
                    issues.append("Rule has empty head")
                if not body.strip().rstrip("."):
                    issues.append("Rule has empty body")

        # Check for overly complex rules (heuristic: > 100 chars)
        if len(rule_text) > 150:
            issues.append(
                "Rule is very long - consider breaking into multiple rules for maintainability"
            )

        return issues

    def validate_program(self, asp_text: str) -> Tuple[bool, Optional[str]]:
        """
        Check if ASP program is syntactically valid.

        Args:
            asp_text: ASP program text to validate

        Returns:
            Tuple of (is_valid, error_message)
            - is_valid: True if syntax is valid
            - error_message: None if valid, error description if invalid

        Example:
            >>> validator = ASPSyntaxValidator()
            >>> is_valid, error = validator.validate_program("fact(a).")
            >>> assert is_valid and error is None
        """
        try:
            ctl = clingo.Control()
            ctl.add("base", [], asp_text)
            logger.debug(f"ASP program syntax validation passed: {len(asp_text)} chars")
            return (True, None)
        except Exception as e:
            error_msg = f"Syntax error: {str(e)}"
            logger.warning(f"ASP syntax validation failed: {error_msg}")
            return (False, error_msg)

    def validate_predicate_types(
        self, asp_text: str, domain_schema: Dict[str, int]
    ) -> Tuple[bool, List[str]]:
        """
        Verify predicates match domain schema (check arities).

        Args:
            asp_text: ASP program text
            domain_schema: Dict mapping predicate names to expected arity
                          e.g., {"contract": 1, "party": 1, "signed_by": 2}

        Returns:
            Tuple of (is_valid, errors)
            - is_valid: True if all predicates match schema
            - errors: List of error messages for mismatches

        Example:
            >>> validator = ASPSyntaxValidator()
            >>> schema = {"fact": 1, "rule": 2}
            >>> valid, errors = validator.validate_predicate_types(
            ...     "fact(a). rule(x, y).", schema
            ... )
            >>> assert valid
        """
        errors = []

        # Parse ASP and extract predicates with their arities
        try:
            # Use Clingo's parsing capabilities
            ctl = clingo.Control()
            ctl.add("base", [], asp_text)
            ctl.ground([("base", [])])

            # Check against schema
            # Note: Full implementation would parse AST to extract predicates
            # For now, basic validation that program is well-formed
            logger.debug("Predicate type validation passed")
            return (True, [])

        except Exception as e:
            errors.append(f"Type checking failed: {str(e)}")
            logger.warning(f"Predicate type validation failed: {errors}")
            return (False, errors)

    def check_stratification(self, asp_text: str) -> Tuple[bool, List[str]]:
        """
        Verify program is stratified (no cycles through negation).

        A program is stratified if there are no cycles in the dependency
        graph that go through negation. This ensures the program has a
        unique stable model.

        Args:
            asp_text: ASP program text

        Returns:
            Tuple of (is_stratified, problematic_rules)
            - is_stratified: True if properly stratified
            - problematic_rules: List of rule descriptions that violate stratification

        Example:
            >>> validator = ASPSyntaxValidator()
            >>> # This is stratified
            >>> is_strat, issues = validator.check_stratification(
            ...     "a :- not b. b :- c."
            ... )
            >>> assert is_strat
        """
        # Basic implementation: check if program grounds without issues
        # Full implementation would analyze dependency graph
        try:
            ctl = clingo.Control()
            ctl.add("base", [], asp_text)
            ctl.ground([("base", [])])

            # If grounding succeeds, stratification is likely OK
            # Clingo handles non-stratified programs, but we prefer stratified
            logger.debug("Stratification check passed")
            return (True, [])

        except Exception as e:
            error_msg = f"Stratification issue: {str(e)}"
            logger.warning(error_msg)
            return (False, [error_msg])


class ASPSemanticValidator:
    """Validates logical consistency and properties of ASP programs."""

    def check_consistency(self, asp_program: str) -> Tuple[bool, str]:
        """
        Check if ASP program has at least one answer set (is satisfiable).

        An inconsistent program has no answer sets, meaning the constraints
        cannot be satisfied.

        Args:
            asp_program: ASP program text to check

        Returns:
            Tuple of (is_consistent, explanation)
            - is_consistent: True if program has answer sets
            - explanation: Description of result

        Example:
            >>> validator = ASPSemanticValidator()
            >>> # Consistent program
            >>> consistent, msg = validator.check_consistency("fact(a).")
            >>> assert consistent
            >>>
            >>> # Inconsistent program
            >>> consistent, msg = validator.check_consistency(
            ...     "a. -a. :- a, -a."
            ... )
            >>> assert not consistent
        """
        try:
            ctl = clingo.Control()
            ctl.add("base", [], asp_program)
            ctl.ground([("base", [])])

            result = ctl.solve()

            if result.satisfiable:
                logger.debug("ASP program is consistent (has answer sets)")
                return (True, "Program has answer sets")
            elif result.unsatisfiable:
                logger.warning("ASP program is inconsistent (no answer sets)")
                return (False, "Program is unsatisfiable (no answer sets)")
            else:
                logger.warning("ASP program satisfiability unknown")
                return (False, "Unknown satisfiability")

        except Exception as e:
            error_msg = f"Consistency check failed: {str(e)}"
            logger.error(error_msg)
            return (False, error_msg)

    def detect_contradictions(self, asp_program: str) -> List[str]:
        """
        Find explicit contradictions like: a(X). -a(X).

        Returns list of contradictory predicate names.

        Args:
            asp_program: ASP program text

        Returns:
            List of predicate names that appear in contradictions

        Example:
            >>> validator = ASPSemanticValidator()
            >>> contradictions = validator.detect_contradictions(
            ...     "valid(x). -valid(x)."
            ... )
            >>> assert "valid" in contradictions
        """
        contradictions = []

        # Basic implementation: check if program is unsatisfiable
        # Full implementation would parse and find specific contradictions
        is_consistent, msg = self.check_consistency(asp_program)

        if not is_consistent and "unsatisfiable" in msg.lower():
            # Program has contradictions
            logger.warning("Contradictions detected in ASP program")
            contradictions.append("program_level_contradiction")

        return contradictions

    def check_rule_composition(self, rule1: str, rule2: str) -> bool:
        """
        Verify that combining two rules doesn't create inconsistency.

        Tests ring structure properties - rules should compose cleanly.

        Args:
            rule1: First ASP rule
            rule2: Second ASP rule

        Returns:
            True if composition is consistent

        Example:
            >>> validator = ASPSemanticValidator()
            >>> # Compatible rules
            >>> assert validator.check_rule_composition(
            ...     "a :- b.",
            ...     "b :- c."
            ... )
            >>>
            >>> # Incompatible rules
            >>> assert not validator.check_rule_composition(
            ...     "a.",
            ...     "-a."
            ... )
        """
        combined = f"{rule1}\n{rule2}"
        is_consistent, _ = self.check_consistency(combined)
        return is_consistent

    def count_answer_sets(self, asp_program: str, max_count: int = 10) -> int:
        """
        Count number of answer sets (up to max).

        Multiple answer sets indicate non-determinism in the program.

        Args:
            asp_program: ASP program text
            max_count: Maximum number of answer sets to count

        Returns:
            Number of answer sets found (up to max_count)

        Example:
            >>> validator = ASPSemanticValidator()
            >>> # Deterministic program (1 answer set)
            >>> count = validator.count_answer_sets("fact(a).")
            >>> assert count == 1
            >>>
            >>> # Non-deterministic program (multiple answer sets)
            >>> count = validator.count_answer_sets(
            ...     "{a; b}."  # Choice rule
            ... )
            >>> assert count > 1
        """
        try:
            # Configure clingo to enumerate all models (0 = all)
            ctl = clingo.Control(["0"])
            ctl.add("base", [], asp_program)
            ctl.ground([("base", [])])

            count = 0

            def on_model(model: clingo.Model) -> bool:
                nonlocal count
                count += 1
                # Return False to stop solving after max_count models
                return count < max_count

            ctl.solve(on_model=on_model)

            logger.debug(f"ASP program has {count} answer set(s)")
            return count

        except Exception as e:
            logger.error(f"Error counting answer sets: {str(e)}")
            return 0

    def get_answer_sets(self, asp_program: str, max_sets: int = 10) -> List[List[clingo.Symbol]]:
        """
        Get all answer sets (up to max_sets) for inspection.

        Args:
            asp_program: ASP program text
            max_sets: Maximum number of answer sets to retrieve

        Returns:
            List of answer sets, where each answer set is a list of symbols

        Example:
            >>> validator = ASPSemanticValidator()
            >>> answer_sets = validator.get_answer_sets("fact(a). fact(b).")
            >>> assert len(answer_sets) == 1
            >>> # Answer set contains fact(a) and fact(b)
        """
        answer_sets = []

        try:
            # Configure clingo to enumerate all models (0 = all)
            ctl = clingo.Control(["0"])
            ctl.add("base", [], asp_program)
            ctl.ground([("base", [])])

            def on_model(model: clingo.Model) -> bool:
                # Get all symbols in the answer set
                symbols = [atom for atom in model.symbols(shown=True)]
                answer_sets.append(symbols)
                # Return False to stop solving after max_sets models
                return len(answer_sets) < max_sets

            ctl.solve(on_model=on_model)

            logger.debug(f"Retrieved {len(answer_sets)} answer set(s)")
            return answer_sets

        except Exception as e:
            logger.error(f"Error retrieving answer sets: {str(e)}")
            return []


def validate_asp_program(asp_text: str) -> Dict[str, Any]:
    """
    Comprehensive validation of an ASP program.

    Runs all validation checks and returns a summary.

    Args:
        asp_text: ASP program text to validate

    Returns:
        Dictionary with validation results:
        {
            "syntax_valid": bool,
            "syntax_error": Optional[str],
            "is_consistent": bool,
            "consistency_msg": str,
            "answer_set_count": int,
            "contradictions": List[str],
            "overall_valid": bool
        }

    Example:
        >>> results = validate_asp_program("fact(a). fact(b).")
        >>> assert results["overall_valid"]
        >>> assert results["syntax_valid"]
        >>> assert results["is_consistent"]
    """
    syntax_validator = ASPSyntaxValidator()
    semantic_validator = ASPSemanticValidator()

    # Syntax validation
    syntax_valid, syntax_error = syntax_validator.validate_program(asp_text)

    if not syntax_valid:
        return {
            "syntax_valid": False,
            "syntax_error": syntax_error,
            "is_consistent": False,
            "consistency_msg": "Skipped due to syntax error",
            "answer_set_count": 0,
            "contradictions": [],
            "overall_valid": False,
        }

    # Semantic validation
    is_consistent, consistency_msg = semantic_validator.check_consistency(asp_text)
    answer_set_count = semantic_validator.count_answer_sets(asp_text)
    contradictions = semantic_validator.detect_contradictions(asp_text)

    overall_valid = syntax_valid and is_consistent

    results = {
        "syntax_valid": syntax_valid,
        "syntax_error": syntax_error,
        "is_consistent": is_consistent,
        "consistency_msg": consistency_msg,
        "answer_set_count": answer_set_count,
        "contradictions": contradictions,
        "overall_valid": overall_valid,
    }

    logger.info(f"ASP validation complete: overall_valid={overall_valid}")
    return results
