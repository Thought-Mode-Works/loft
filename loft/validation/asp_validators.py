"""
ASP-specific validators for Answer Set Programming syntax and structure.

This module provides validation for ASP programs using Clingo, including:
- Syntax validation
- Type checking
- Stratification verification
- Satisfiability checking
- LLM-generated rule validation
- Undefined predicate detection
- Grounding validation
"""

from typing import Tuple, List, Optional, Dict, Any, Set
import re
import clingo
from loguru import logger

from loft.validation.validation_schemas import ValidationResult
from loft.neural.rule_schemas import (
    check_undefined_predicates,
    validate_rule_grounds,
)


class ASPSyntaxValidator:
    """Validates ASP program syntax and structure."""

    def __init__(
        self,
        strict_undefined_predicates: bool = False,
        validate_grounding: bool = False,
    ):
        """
        Initialize the ASP syntax validator.

        Args:
            strict_undefined_predicates: If True, undefined predicates cause rejection
            validate_grounding: If True, test that rules ground with sample facts
        """
        self.strict_undefined_predicates = strict_undefined_predicates
        self.validate_grounding = validate_grounding

    def validate_generated_rule(
        self,
        rule_text: str,
        existing_predicates: Optional[List[str]] = None,
        sample_facts: Optional[str] = None,
    ) -> ValidationResult:
        """
        Validate an LLM-generated ASP rule with comprehensive checks.

        This method performs specialized validation for rules generated by LLMs,
        including syntax, naming conventions, structural checks, undefined
        predicate detection, and optional grounding validation.

        Args:
            rule_text: The ASP rule to validate
            existing_predicates: Optional list of existing predicates
                                 (e.g., ["contract/1", "party/2"] or ["contract", "party"])
            sample_facts: Optional sample facts to test grounding against

        Returns:
            ValidationResult with detailed error messages and warnings

        Example:
            >>> validator = ASPSyntaxValidator(strict_undefined_predicates=True)
            >>> result = validator.validate_generated_rule(
            ...     "enforceable(C) :- contract(C), not void(C).",
            ...     existing_predicates=["contract/1", "void/1"]
            ... )
            >>> assert result.is_valid
        """
        errors = []
        warnings = []
        details = {}

        # 1. Basic syntax validation with Clingo
        syntax_valid, syntax_error = self.validate_program(rule_text)
        if not syntax_valid:
            errors.append(f"Syntax error: {syntax_error}")
            return ValidationResult(
                is_valid=False,
                error_messages=errors,
                warnings=warnings,
                details={"syntax_error": syntax_error},
                stage_name="syntactic",
            )

        # 2. Variable naming convention check (uppercase)
        variable_issues = self._check_variable_naming(rule_text)
        if variable_issues:
            warnings.extend(variable_issues)
            details["variable_naming_issues"] = variable_issues

        # 3. Predicate naming convention check (lowercase, underscore-separated)
        predicate_issues = self._check_predicate_naming(rule_text)
        if predicate_issues:
            warnings.extend(predicate_issues)
            details["predicate_naming_issues"] = predicate_issues

        # 4. Check for proper negation syntax
        negation_issues = self._check_negation_syntax(rule_text)
        if negation_issues:
            errors.extend(negation_issues)
            details["negation_issues"] = negation_issues

        # 5. Check for constraint formatting
        constraint_issues = self._check_constraint_formatting(rule_text)
        if constraint_issues:
            warnings.extend(constraint_issues)
            details["constraint_issues"] = constraint_issues

        # 6. Validate against existing predicates if provided
        if existing_predicates:
            predicate_compatibility = self._check_predicate_compatibility(
                rule_text, existing_predicates
            )
            if predicate_compatibility:
                details["new_predicates"] = predicate_compatibility.get("new_predicates", [])
                details["used_predicates"] = predicate_compatibility.get("used_predicates", [])

            # 6b. Check for undefined predicates (new in issue #101)
            known_pred_names = self._extract_predicate_names(existing_predicates)
            undef_errors, undef_warnings = check_undefined_predicates(
                rule_text, known_pred_names, strict=self.strict_undefined_predicates
            )
            errors.extend(undef_errors)
            warnings.extend(undef_warnings)
            if undef_errors or undef_warnings:
                details["undefined_predicates"] = undef_errors + undef_warnings

        # 7. Check for common LLM generation issues
        llm_issues = self._check_common_llm_issues(rule_text)
        if llm_issues:
            warnings.extend(llm_issues)
            details["llm_generation_issues"] = llm_issues

        # 8. Grounding validation (new in issue #101)
        if self.validate_grounding and sample_facts:
            grounds, grounding_error = validate_rule_grounds(rule_text, sample_facts)
            if not grounds:
                warnings.append(f"Grounding issue: {grounding_error}")
                details["grounding_issue"] = grounding_error

        is_valid = len(errors) == 0

        return ValidationResult(
            is_valid=is_valid,
            error_messages=errors,
            warnings=warnings,
            details=details,
            stage_name="syntactic",
        )

    def _extract_predicate_names(self, predicate_specs: List[str]) -> Set[str]:
        """
        Extract predicate names from predicate specs.

        Args:
            predicate_specs: List like ["contract/1", "party/2"] or ["contract", "party"]

        Returns:
            Set of predicate names
        """
        names = set()
        for spec in predicate_specs:
            if "/" in spec:
                name = spec.split("/")[0]
            else:
                name = spec
            names.add(name.strip())
        return names

    def _check_variable_naming(self, rule_text: str) -> List[str]:
        """Check that variables follow uppercase naming convention."""
        issues = []

        # Find potential variables (words in rule that start with lowercase in head/body positions)
        # This is a heuristic check - proper parsing would use Clingo AST
        var_pattern = r"\b([a-z][a-zA-Z0-9_]*)\b"
        matches = re.finditer(var_pattern, rule_text)

        lowercase_in_args = []
        for match in matches:
            var = match.group(1)
            # Check if it appears in argument position (after '(' or ',')
            pos = match.start()
            if pos > 0 and rule_text[pos - 1] in "(,":
                # Exclude predicate names (those followed by '(')
                if match.end() < len(rule_text) and rule_text[match.end()] != "(":
                    lowercase_in_args.append(var)

        if lowercase_in_args:
            issues.append(
                f"Potential variable naming issue: variables should be uppercase. "
                f"Found lowercase in argument positions: {', '.join(set(lowercase_in_args[:5]))}"
            )

        return issues

    def _check_predicate_naming(self, rule_text: str) -> List[str]:
        """Check that predicates follow naming conventions."""
        issues = []

        # Find predicate names (words followed by '(')
        pred_pattern = r"([A-Z][a-zA-Z0-9_]*)\s*\("
        matches = re.finditer(pred_pattern, rule_text)

        uppercase_predicates = [m.group(1) for m in matches]

        if uppercase_predicates:
            issues.append(
                f"Predicate naming convention: predicates should start with lowercase. "
                f"Found uppercase predicates: {', '.join(set(uppercase_predicates))}"
            )

        return issues

    def _check_negation_syntax(self, rule_text: str) -> List[str]:
        """Check for proper negation syntax."""
        errors = []

        # Check for improper negation patterns
        # ASP uses 'not' for default negation, '-' for classical negation

        # Look for common mistakes like '!' instead of 'not'
        if "!" in rule_text and "not" not in rule_text:
            errors.append("Invalid negation syntax: use 'not' instead of '!'")

        # Check for negation with missing space
        if re.search(r"not[a-zA-Z]", rule_text):
            errors.append("Negation syntax: 'not' should be followed by a space")

        return errors

    def _check_constraint_formatting(self, rule_text: str) -> List[str]:
        """Check constraint formatting."""
        issues = []

        # Check if this is a constraint (starts with ':-')
        if rule_text.strip().startswith(":-"):
            # Good practice: constraints should have clear variable usage
            if not any(var in rule_text for var in ["(X)", "(Y)", "(C)", "(P)"]):
                issues.append("Constraint may need explicit variables for clarity")

        return issues

    def _check_predicate_compatibility(
        self, rule_text: str, existing_predicates: List[str]
    ) -> Dict[str, List[str]]:
        """
        Check which predicates are used vs new.

        Args:
            rule_text: The rule text
            existing_predicates: List of predicates in format "name/arity"

        Returns:
            Dict with "new_predicates" and "used_predicates" lists
        """
        # Parse existing predicates into a dict
        existing_dict = {}
        for pred_spec in existing_predicates:
            if "/" in pred_spec:
                name, arity = pred_spec.split("/")
                existing_dict[name] = int(arity)

        # Extract predicates from rule (simplified heuristic)
        pred_pattern = r"([a-z][a-z0-9_]*)\s*\("
        found_predicates = set(re.findall(pred_pattern, rule_text))

        new_predicates = []
        used_predicates = []

        for pred in found_predicates:
            if pred in existing_dict:
                used_predicates.append(pred)
            else:
                new_predicates.append(pred)

        return {
            "new_predicates": new_predicates,
            "used_predicates": used_predicates,
        }

    def _check_common_llm_issues(self, rule_text: str) -> List[str]:
        """Check for common issues in LLM-generated rules."""
        issues = []

        # Check for missing period at end
        if not rule_text.strip().endswith("."):
            issues.append("Rule should end with a period (.)")

        # Check for multiple rules in one string (should be split)
        if rule_text.count(".") > 1:
            issues.append("Multiple rules detected - consider validating separately")

        # Check for incomplete rules (empty body or head)
        if ":-" in rule_text:
            parts = rule_text.split(":-")
            if len(parts) == 2:
                head, body = parts
                if not head.strip():
                    issues.append("Rule has empty head")
                if not body.strip().rstrip("."):
                    issues.append("Rule has empty body")

        # Check for overly complex rules (heuristic: > 100 chars)
        if len(rule_text) > 150:
            issues.append(
                "Rule is very long - consider breaking into multiple rules for maintainability"
            )

        return issues

    def validate_program(self, asp_text: str) -> Tuple[bool, Optional[str]]:
        """
        Check if ASP program is syntactically valid.

        Args:
            asp_text: ASP program text to validate

        Returns:
            Tuple of (is_valid, error_message)
            - is_valid: True if syntax is valid
            - error_message: None if valid, error description if invalid

        Example:
            >>> validator = ASPSyntaxValidator()
            >>> is_valid, error = validator.validate_program("fact(a).")
            >>> assert is_valid and error is None
        """
        try:
            ctl = clingo.Control()
            ctl.add("base", [], asp_text)
            logger.debug(f"ASP program syntax validation passed: {len(asp_text)} chars")
            return (True, None)
        except Exception as e:
            error_msg = f"Syntax error: {str(e)}"
            logger.warning(f"ASP syntax validation failed: {error_msg}")
            return (False, error_msg)

    def validate_predicate_types(
        self, asp_text: str, domain_schema: Dict[str, int]
    ) -> Tuple[bool, List[str]]:
        """
        Verify predicates match domain schema (check arities).

        Args:
            asp_text: ASP program text
            domain_schema: Dict mapping predicate names to expected arity
                          e.g., {"contract": 1, "party": 1, "signed_by": 2}

        Returns:
            Tuple of (is_valid, errors)
            - is_valid: True if all predicates match schema
            - errors: List of error messages for mismatches

        Example:
            >>> validator = ASPSyntaxValidator()
            >>> schema = {"fact": 1, "rule": 2}
            >>> valid, errors = validator.validate_predicate_types(
            ...     "fact(a). rule(x, y).", schema
            ... )
            >>> assert valid
        """
        errors = []

        # Parse ASP and extract predicates with their arities
        try:
            # Use Clingo's parsing capabilities
            ctl = clingo.Control()
            ctl.add("base", [], asp_text)
            ctl.ground([("base", [])])

            # Check against schema
            # Note: Full implementation would parse AST to extract predicates
            # For now, basic validation that program is well-formed
            logger.debug("Predicate type validation passed")
            return (True, [])

        except Exception as e:
            errors.append(f"Type checking failed: {str(e)}")
            logger.warning(f"Predicate type validation failed: {errors}")
            return (False, errors)

    def check_stratification(self, asp_text: str) -> Tuple[bool, List[str]]:
        """
        Verify program is stratified (no cycles through negation).

        A program is stratified if there are no cycles in the dependency
        graph that go through negation. This ensures the program has a
        unique stable model.

        Args:
            asp_text: ASP program text

        Returns:
            Tuple of (is_stratified, problematic_rules)
            - is_stratified: True if properly stratified
            - problematic_rules: List of rule descriptions that violate stratification

        Example:
            >>> validator = ASPSyntaxValidator()
            >>> # This is stratified
            >>> is_strat, issues = validator.check_stratification(
            ...     "a :- not b. b :- c."
            ... )
            >>> assert is_strat
        """
        # Basic implementation: check if program grounds without issues
        # Full implementation would analyze dependency graph
        try:
            ctl = clingo.Control()
            ctl.add("base", [], asp_text)
            ctl.ground([("base", [])])

            # If grounding succeeds, stratification is likely OK
            # Clingo handles non-stratified programs, but we prefer stratified
            logger.debug("Stratification check passed")
            return (True, [])

        except Exception as e:
            error_msg = f"Stratification issue: {str(e)}"
            logger.warning(error_msg)
            return (False, [error_msg])


class ASPSemanticValidator:
    """Validates logical consistency and properties of ASP programs."""

    def check_consistency(self, asp_program: str) -> Tuple[bool, str]:
        """
        Check if ASP program has at least one answer set (is satisfiable).

        An inconsistent program has no answer sets, meaning the constraints
        cannot be satisfied.

        Args:
            asp_program: ASP program text to check

        Returns:
            Tuple of (is_consistent, explanation)
            - is_consistent: True if program has answer sets
            - explanation: Description of result

        Example:
            >>> validator = ASPSemanticValidator()
            >>> # Consistent program
            >>> consistent, msg = validator.check_consistency("fact(a).")
            >>> assert consistent
            >>>
            >>> # Inconsistent program
            >>> consistent, msg = validator.check_consistency(
            ...     "a. -a. :- a, -a."
            ... )
            >>> assert not consistent
        """
        try:
            ctl = clingo.Control()
            ctl.add("base", [], asp_program)
            ctl.ground([("base", [])])

            result = ctl.solve()

            if result.satisfiable:
                logger.debug("ASP program is consistent (has answer sets)")
                return (True, "Program has answer sets")
            elif result.unsatisfiable:
                logger.warning("ASP program is inconsistent (no answer sets)")
                return (False, "Program is unsatisfiable (no answer sets)")
            else:
                logger.warning("ASP program satisfiability unknown")
                return (False, "Unknown satisfiability")

        except Exception as e:
            error_msg = f"Consistency check failed: {str(e)}"
            logger.error(error_msg)
            return (False, error_msg)

    def detect_contradictions(self, asp_program: str) -> List[str]:
        """
        Find explicit contradictions like: a(X). -a(X).

        Returns list of contradictory predicate names.

        Args:
            asp_program: ASP program text

        Returns:
            List of predicate names that appear in contradictions

        Example:
            >>> validator = ASPSemanticValidator()
            >>> contradictions = validator.detect_contradictions(
            ...     "valid(x). -valid(x)."
            ... )
            >>> assert "valid" in contradictions
        """
        contradictions = []

        # Basic implementation: check if program is unsatisfiable
        # Full implementation would parse and find specific contradictions
        is_consistent, msg = self.check_consistency(asp_program)

        if not is_consistent and "unsatisfiable" in msg.lower():
            # Program has contradictions
            logger.warning("Contradictions detected in ASP program")
            contradictions.append("program_level_contradiction")

        return contradictions

    def check_rule_composition(self, rule1: str, rule2: str) -> bool:
        """
        Verify that combining two rules doesn't create inconsistency.

        Tests ring structure properties - rules should compose cleanly.

        Args:
            rule1: First ASP rule
            rule2: Second ASP rule

        Returns:
            True if composition is consistent

        Example:
            >>> validator = ASPSemanticValidator()
            >>> # Compatible rules
            >>> assert validator.check_rule_composition(
            ...     "a :- b.",
            ...     "b :- c."
            ... )
            >>>
            >>> # Incompatible rules
            >>> assert not validator.check_rule_composition(
            ...     "a.",
            ...     "-a."
            ... )
        """
        combined = f"{rule1}\n{rule2}"
        is_consistent, _ = self.check_consistency(combined)
        return is_consistent

    def count_answer_sets(self, asp_program: str, max_count: int = 10) -> int:
        """
        Count number of answer sets (up to max).

        Multiple answer sets indicate non-determinism in the program.

        Args:
            asp_program: ASP program text
            max_count: Maximum number of answer sets to count

        Returns:
            Number of answer sets found (up to max_count)

        Example:
            >>> validator = ASPSemanticValidator()
            >>> # Deterministic program (1 answer set)
            >>> count = validator.count_answer_sets("fact(a).")
            >>> assert count == 1
            >>>
            >>> # Non-deterministic program (multiple answer sets)
            >>> count = validator.count_answer_sets(
            ...     "{a; b}."  # Choice rule
            ... )
            >>> assert count > 1
        """
        try:
            # Configure clingo to enumerate all models (0 = all)
            ctl = clingo.Control(["0"])
            ctl.add("base", [], asp_program)
            ctl.ground([("base", [])])

            count = 0

            def on_model(model: clingo.Model) -> bool:
                nonlocal count
                count += 1
                # Return False to stop solving after max_count models
                return count < max_count

            ctl.solve(on_model=on_model)

            logger.debug(f"ASP program has {count} answer set(s)")
            return count

        except Exception as e:
            logger.error(f"Error counting answer sets: {str(e)}")
            return 0

    def get_answer_sets(self, asp_program: str, max_sets: int = 10) -> List[List[clingo.Symbol]]:
        """
        Get all answer sets (up to max_sets) for inspection.

        Args:
            asp_program: ASP program text
            max_sets: Maximum number of answer sets to retrieve

        Returns:
            List of answer sets, where each answer set is a list of symbols

        Example:
            >>> validator = ASPSemanticValidator()
            >>> answer_sets = validator.get_answer_sets("fact(a). fact(b).")
            >>> assert len(answer_sets) == 1
            >>> # Answer set contains fact(a) and fact(b)
        """
        answer_sets = []

        try:
            # Configure clingo to enumerate all models (0 = all)
            ctl = clingo.Control(["0"])
            ctl.add("base", [], asp_program)
            ctl.ground([("base", [])])

            def on_model(model: clingo.Model) -> bool:
                # Get all symbols in the answer set
                symbols = [atom for atom in model.symbols(shown=True)]
                answer_sets.append(symbols)
                # Return False to stop solving after max_sets models
                return len(answer_sets) < max_sets

            ctl.solve(on_model=on_model)

            logger.debug(f"Retrieved {len(answer_sets)} answer set(s)")
            return answer_sets

        except Exception as e:
            logger.error(f"Error retrieving answer sets: {str(e)}")
            return []


def validate_asp_program(asp_text: str) -> Dict[str, Any]:
    """
    Comprehensive validation of an ASP program.

    Runs all validation checks and returns a summary.

    Args:
        asp_text: ASP program text to validate

    Returns:
        Dictionary with validation results:
        {
            "syntax_valid": bool,
            "syntax_error": Optional[str],
            "is_consistent": bool,
            "consistency_msg": str,
            "answer_set_count": int,
            "contradictions": List[str],
            "overall_valid": bool
        }

    Example:
        >>> results = validate_asp_program("fact(a). fact(b).")
        >>> assert results["overall_valid"]
        >>> assert results["syntax_valid"]
        >>> assert results["is_consistent"]
    """
    syntax_validator = ASPSyntaxValidator()
    semantic_validator = ASPSemanticValidator()

    # Syntax validation
    syntax_valid, syntax_error = syntax_validator.validate_program(asp_text)

    if not syntax_valid:
        return {
            "syntax_valid": False,
            "syntax_error": syntax_error,
            "is_consistent": False,
            "consistency_msg": "Skipped due to syntax error",
            "answer_set_count": 0,
            "contradictions": [],
            "overall_valid": False,
        }

    # Semantic validation
    is_consistent, consistency_msg = semantic_validator.check_consistency(asp_text)
    answer_set_count = semantic_validator.count_answer_sets(asp_text)
    contradictions = semantic_validator.detect_contradictions(asp_text)

    overall_valid = syntax_valid and is_consistent

    results = {
        "syntax_valid": syntax_valid,
        "syntax_error": syntax_error,
        "is_consistent": is_consistent,
        "consistency_msg": consistency_msg,
        "answer_set_count": answer_set_count,
        "contradictions": contradictions,
        "overall_valid": overall_valid,
    }

    logger.info(f"ASP validation complete: overall_valid={overall_valid}")
    return results
